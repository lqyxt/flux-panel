# Development Rules

## Repository Layout
- `go-gost/`: vendored gost control binary and related Go glue code; treat as upstream dependency, do not modify without upstream sync plan.
- `springboot-backend/`: Java 21 Spring Boot 2.7 application using MyBatis-Plus, Hutool, and Lombok; hosts REST APIs, schedulers, WebSocket bridge.
- `vite-frontend/`: React 18 + TypeScript + Vite UI backed by HeroUI components and Tailwind utilities.
- `vitepress/`: documentation site sources; keep public docs in Markdown here.
- `docker-compose.yml`: default runtime composition shipped with the panel, parameterised through environment variables generated by installers.
- Shell scripts (`panel_install.sh`, `install.sh`, `proxy.sh`): provisioning helpers for panel and node.
- `gost.sql`: authoritative schema bootstrap; reflects MySQL 5.7 compatible structure.

## General Principles
- Keep files ASCII with LF line endings; avoid BOM and stray whitespace.
- Prefer small, focused changes; keep unrelated edits out of the same change set.
- Follow existing minimal-comment style: only document non-obvious intent or complex flows.
- Stick to dependency versions already locked unless coordinated upgrade (backend via Maven, frontend via package.json, Go via go.mod).
- Validate scripts and configs on Linux-compatible shells; avoid features unavailable in busybox ash.

## Git Workflow
- Work in feature branches (`feature/...`, `fix/...`, `chore/...`) branched from `main`; keep `main` release-ready.
- Use Conventional Commit messages: `feat:`, `fix:`, `chore:`, `docs:`, `refactor:`, `test:` etc.
- Before pushing, run relevant linters/tests and ensure `git status` is clean.
- Do not rewrite shared history on `main`; use merge or rebase locally before pull requests.

## Backend (springboot-backend)
- Java 21, Spring Boot 2.7: configure via `application-*.yml`; respect existing Bean component scan under `com.admin`.
- Use Lombok for entities/DTOs; avoid manual getters unless necessary.
- Persistence: favor MyBatis-Plus `ServiceImpl` and `Mapper` patterns already in place; use `QueryWrapper` for dynamic queries.
- DTO validation: leverage `javax.validation` annotations (`@NotNull`, `@DecimalMin`, etc.) and validate at controller level.
- Keep business logic inside service layer; controllers should stay thin (request validation + service delegation).
- Async tasks belong in `com.admin.common.task`; ensure thread safety when updating shared state.
- When adding database fields, update entity, DTO, mapper, and `gost.sql`; provide default values/backfill logic in install scripts.
- Logging: rely on existing Slf4j `log` instances; use structured messages for operations (tunnel/service IDs).

## Frontend (vite-frontend)
- React 18 with Vite; keep components functional and hook-based.
- Organise features under `src/pages`, shared UI in `src/components`, utilities in `src/utils`, API calls in `src/api` (axios wrapper).
- Use TypeScript types/interfaces for all data models; keep API payload types in sync with backend DTOs.
- Styling: rely on HeroUI props and Tailwind utilities; avoid ad-hoc inline styles unless necessary.
- Run `npm run lint` (or pnpm equivalent) before commits; resolve ESLint and Prettier warnings.
- Maintain consistent toast/notification patterns (react-hot-toast) for user feedback.
- Route definitions live in `App.tsx`; match backend endpoints and guard admin-only routes as needed.

## Documentation (vitepress)
- Update public-facing docs in `vitepress` when behaviour or configuration changes.
- Keep Markdown front-matter and sidebar order consistent with existing pages.
- For CLI usage or API guides, prefer tables and step-by-step lists similar to current docs.

## Shell Scripts & Installers
- Maintain POSIX compatibility (bash, but avoid GNU-only extensions when possible).
- Preserve current user prompts and emoji output style; new functions should follow existing logging pattern.
- Always back up or check for existing files before overwriting (as with docker-compose and gost.sql).
- When scripts generate credentials, utilise existing `generate_random` helper; store secrets in `.env` or compose env file, not plain logs.

## Database & Migrations
- Schema source of truth is `gost.sql`; apply forward-only changes (append alter statements) and keep install scripts idempotent.
- Any new table/column must include indexes, default values, and comments mirroring existing style.
- Coordinate data migrations with backend logic (e.g., when adding tunnel properties ensure service handles null/default states).

## Containerisation & Deployment
- `docker-compose.yml` is the baseline; keep services named consistently (`gost-mysql`, `springboot-backend`, `vite-frontend`).
- Map configuration via environment variables generated during install; avoid hardcoding secrets.
- Health checks should use simple, dependency-free commands (curl/wget) and stay within current retry envelopes.
- When exposing new services, document ports and env vars in install script prompts and docs.

## Testing & Quality Gates
- Backend: run `mvn clean test` and, when applicable, targeted integration tests before shipping behaviour changes.
- Frontend: run `npm run build` and `npm run lint`; add component/unit tests when introducing complex logic.
- Shell: manual smoke test on a clean Linux environment after significant changes (install/update/uninstall flows).
- Record manual verification steps in pull requests for traceability.

## Release Checklist
- Update changelog or release notes in `vitepress` if user-facing changes occur.
- Ensure docker images referenced in compose file are available (tagged) before release.
- Verify install/update scripts against fresh servers (IPv4 and IPv6) when altering provisioning logic.
- Tag releases on `main` after all checks pass.
